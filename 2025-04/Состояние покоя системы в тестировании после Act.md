# Концепт «стазиса» в тестировании: состояние покоя системы после Act

## Аналоги и устоявшиеся термины 
Идея «стазиса» – когда после действия (Act) система полностью **стабилизировалась** и никаких фоновых задач больше не выполняется – известна в тестировании, хотя обычно используется другая терминология. Наиболее близкий по смыслу термин – **«тихое» или покоящееся состояние** системы, часто называемое *quiescent state* (квиесцентное состояние) или просто *idle state* (бездействие). Например, в инструменте Microsoft CHESS для системного тестирования конкуррентного кода есть метод `Chess.Quiesce`, который **ждет, пока система не достигнет квиесцентного состояния**, то есть фактически момента, когда все побочные таски завершены ([(PDF) CHESS: A systematic testing tool for concurrent software](https://www.academia.edu/7579489/CHESS_A_systematic_testing_tool_for_concurrent_software#:~:text=scenario%20from%20one%20quiescent%20state,1)). В таком состоянии «покоя» основная нить выполнения иницииирует проверку, убедившись, что фоновые задачи остановлены или заблокированы, как при *deadlock*, но контролируемо ([(PDF) CHESS: A systematic testing tool for concurrent software](https://www.academia.edu/7579489/CHESS_A_systematic_testing_tool_for_concurrent_software#:~:text=quiescent%20state%20is%20one%20in,of%20them%20to%20terminate%20before)). 

В UI-тестировании и интеграционных тестах часто говорят об **«idle» (бездействующем) состоянии**. Фреймворки автоматизации тестов стараются дождаться, когда интерфейс или система **становятся неактивными перед проверками**. Например, Android Espresso *автоматически синхронизируется* с приложением, **ожидая, когда UI-поток станет idle**, прежде чем выполнять следующую проверку или действие ([A Comprehensive Guide To Espresso Testing | by Abhaya | Medium](https://medium.com/@abhaykhs/a-comprehensive-guide-to-espresso-testing-5149de2b1470#:~:text=2,making%20espresso%20automation%20more%20reliable)). Это гарантирует, что после клика или другого события все связанные асинхронные операции (отрисовка, обработка событий, сетевые запросы и т.д.) завершены, и UI стабилен – как раз состояние, эквивалентное описываемому «стазису». Аналогично, фреймворк XCUITest для iOS тоже по умолчанию ждет завершения активностей (анимаций, сетевых операций), прежде чем продолжить, чтобы тесты были стабильными. В Ember.js используется понятие **«settled state»** (*состояние устойчивости*): хелпер `await settled()` ждет, пока **не останется незавершённых таймеров, запросов или иных отложенных действий** – фактически, пока *run loop* приложения не опустеет ([Ember test with async await functions not working as intended - Testing - Ember.JS](https://discuss.emberjs.com/t/ember-test-with-async-await-functions-not-working-as-intended/18435#:~:text=Lets%20break%20down%20what%20is,this%20context%20is%20defined%20as)). 

Таким образом, хотя термин «стазис» не закрепился, **концепция устойчивого, спокойного состояния системы** после выполнения действий хорошо известна. В англоязычных источниках чаще встретятся термины вроде *quiescence/quiescent state*, *idle*, *settled/settledness*. В русскоязычной литературе по тестированию можно встретить описание *стационарного состояния* системы. Например, в формальных методах (IOCO-модели) вводится понятие, эквивалентное тишине системы – отсутствие выходных воздействий в течение некоторого времени, что интерпретируется как специальное состояние покоя системы для продолжения тестирования. Однако непосредственно слово «стазис» в контексте тестирования практически не употребляется – разве что в качестве метафоры. 

## Использование метафоры «стазис» 
Прямых свидетельств, что термин **«стазис»** уже где-то закрепился именно в тестерском сленге, не найдено. Скорее всего, это авторское образное название, навеянное научной фантастикой (stasis – полная остановка развития процессов). Тем не менее, аналогичная метафора *«заморозки системы»* прослеживается в рассуждениях о стабильном состоянии. Например, иногда говорят, что система достигает **равновесия или покоя** (*equilibrium, idle period*), когда на вход не подается новых событий и все фоновые задачи завершились. На практике же специалисты используют более технические формулировки: *“wait for the system to settle”* (дождаться, пока система «устоится»), или *“await quiescence”* (подождать квиесценции). В обсуждениях разработчиков можно встретить фразу вроде: *«дождаться момента, когда система входит в период покоя (quiescence period)»*, чтобы убедиться, что без внешнего вмешательства она больше не изменит состояние ([Discourage manual execution control in the test framework · Issue #3919 · Kotlin/kotlinx.coroutines · GitHub](https://github.com/Kotlin/kotlinx.coroutines/issues/3919#:~:text=system%20reaches%20a%20quiescence%20period,could%20you%20elaborate%20on%20them)). По сути, **метафора «стазиса» эквивалентна представлению о том, что система находится в “suspended animation”** – активность приостановлена, все силы уравновешены, и можно безопасно исследовать ее состояние. Но повторим: ни в официальной документации, ни в популярных блогах по тестированию термин *«стазис»* не фигурирует. Вместо него говорят о *ожидании завершения всех асинхронных операций* или *достижении состояния покоя*. 

Интересно, что близкое понятие *quiescence* используется не только в тестах, но и в других областях компьютерных наук (например, алгоритмы, CRDT, сборщики мусора) для обозначения периодов, когда активность приостанавливается. В тестировании же это чаще всего всплывает в контексте **асинхронных и многопоточных сценариев**, где нужно явно или неявно дождаться, пока система перестанет «шевелиться», перед тем как делать Assertions.

## Практические способы достижения «тихого» состояния 
На практике тестировщики применяют различные **средства синхронизации**, чтобы гарантировать наступление этого состояния покоя перед проверкой результатов. Вот несколько распространенных подходов и инструментов:

- **Явное ожидание завершения задач:** В простейшем случае тест напрямую ждет окончания асинхронных операций. Например, в Java можно использовать `CountDownLatch` или вызов `Future.join()`/`get()`, чтобы **блокировать тест до завершения фоновых потоков** ([Тестирование асинхронных процессов с JUnit: интеграционные тесты](https://sky.pro/wiki/java/testirovanie-asinkhronnykh-protsessov-s-j-unit-integratsionnye-testy/#:~:text=%40Test%20public%20void%20testAsyncMethod,start)) ([Тестирование асинхронных процессов с JUnit: интеграционные тесты](https://sky.pro/wiki/java/testirovanie-asinkhronnykh-protsessov-s-j-unit-integratsionnye-testy/#:~:text=%40Test%20public%20void%20testAsyncMethod%28%29%20,join%28%29%3B%20%2F%2F%20%D0%9F%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D0%B0%20%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B9)). В .NET аналогично дожидаются `Task` через `await` или методы `Task.WaitAll`. В JavaScript-тестах (Jest, Mocha) принято либо возвращать `Promise`/вызывать `done()` колбэк, либо использовать `async/await`, чтобы фреймворк понял, когда тестируемый код полностью отработал ([Тестирование асинхронного кода - Jest](https://jestjs.io/ru/docs/asynchronous#:~:text=%D0%A3%D0%B1%D0%B5%D0%B4%D0%B8%D1%82%D0%B5%D1%81%D1%8C%2C%20%D1%87%D1%82%D0%BE%20%D0%B2%D1%8B%20%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D1%82%D0%B5%20%D0%BF%D1%80%D0%BE%D0%BC%D0%B8%D1%81,%D0%B4%D0%BE%20%D1%82%D0%BE%D0%B3%D0%BE%2C%20%D0%BA%D0%B0%D0%BA%20%D0%BF%D1%80%D0%BE%D0%BC%D0%B8%D1%81%2C)). Если этого не сделать, тест завершится раньше времени, пока промисы еще выполняются.

- **Утилиты для ожидания условий:** Вместо жестких `sleep` задержек (чреватых неопределенностью) применяются библиотеки, которые **ожидают наступления условного события**. В мире Java популярен Awaitility – инструмент, специально созданный для синхронизации асинхронных действий в тестах. С помощью Fluent-API можно ждать до заданного таймаута, пока не будет выполнено указанное условие или ассерт, например: `Awaitility.await().atMost(5, SECONDS).untilAsserted(...)`. Как отмечают материалы, *Awaitility* – **«инструмент для синхронизации асинхронных операций»** ([Тестирование асинхронных процессов с JUnit: интеграционные тесты](https://sky.pro/wiki/java/testirovanie-asinkhronnykh-protsessov-s-j-unit-integratsionnye-testy/#:~:text=2,%D0%B2%20JUnit%20%D0%BD%D0%B0%20Stack%20Overflow)), позволяющий элегантно дождаться, пока система достигнет нужного состояния.

- **Встроенные возможности фреймворков:** Многие фреймворки тестирования UI и фронтенда *автоматически ждут* стабилизации. Мы уже упоминали Android Espresso, где эта автоматическая синхронизация с UI-потоком снижает флаки (нестабильность тестов) ([A Comprehensive Guide To Espresso Testing | by Abhaya | Medium](https://medium.com/@abhaykhs/a-comprehensive-guide-to-espresso-testing-5149de2b1470#:~:text=2,making%20espresso%20automation%20more%20reliable)). В Angular есть утилита `fixture.whenStable()`, которая **возвращает Promise, выполняющийся, когда все задачи в Angular Zone завершены** ([unit testing - Does fixture.whenStable() actually do anything in my angular tests if not within an async test execution zone? - Stack Overflow](https://stackoverflow.com/questions/53479998/does-fixture-whenstable-actually-do-anything-in-my-angular-tests-if-not-within#:~:text=No%20the%20,just%20returns%20immediately)). Аналогично, при использовании `fakeAsync` + `tick()` Angular обеспечивает эмуляцию асинхронных вызовов, позволяя тесту синхронно «дожать» все отложенные действия. В Ember.js тестовые хелперы по умолчанию используют `await settled()`, чтобы **дождаться завершения всех запланированных таймеров, AJAX-запросов, рендеров и т.д.**, прежде чем переходить к следующим шагам ([Ember test with async await functions not working as intended - Testing - Ember.JS](https://discuss.emberjs.com/t/ember-test-with-async-await-functions-not-working-as-intended/18435#:~:text=Lets%20break%20down%20what%20is,this%20context%20is%20defined%20as)). Эти средства дают “из коробки” эффект, похожий на введение системы в стазис: тест не пойдет дальше, пока фреймворк не убедится, что система скучала и готова к инспекции.

- **Специализированные синхронизаторы:** В некоторых случаях разрабатываются *кастомные механизмы ожидания*. Например, для React Native и мобильных приложений используется фреймворк Detox, который отслеживает активность (сетевые запросы, анимации) и ждет *idle state*, или в Android можно регистрировать **Idling Resources**, указывающие Espresso, когда приложения занято или свободно. В многопоточных системах могут применяться тестовые *барьеры* или *флаги*, сигнализирующие окончание фоновой работы. В сообществе Elixir, как поделились разработчики, можно, к примеру, **отслеживать завершение всех асинхронных задач**: супервизору задач в тесте посылаются мониторы и тест ждет сообщений `:DOWN` от каждого таска ([
A Better Solution for Waiting for Async Tasks in Tests
    ](https://dockyard.com/blog/2024/06/06/a-better-solution-for-waiting-for-async-tasks-in-tests#:~:text=A%20better%20solution%20is%20to,that%20can%20help%20with%20that)) ([
A Better Solution for Waiting for Async Tasks in Tests
    ](https://dockyard.com/blog/2024/06/06/a-better-solution-for-waiting-for-async-tasks-in-tests#:~:text=Then%20in%20your%20test%2C%20you,for%20the%20tasks%20to%20complete)) – такой подход «сбрасывает» систему в состояние без запущенных тасков прежде, чем делать проверки.

- **Контролируемое управление временем:** Для тестирования сложных асинхронных сценариев существуют подходы *симуляции времени*. Это позволяет достигнуть состояния покоя быстрее, не дожидаясь реальных таймаутов. Пример – тестовые планировщики: в .NET можно использовать `VirtualTimeScheduler`, в iOS – подставить *run loop* в ручной режим, в Kotlin Coroutines – библиотеку `kotlinx.coroutines.test`. Последняя предоставляет метод `advanceUntilIdle()`, который **продвигает виртуальное время, выполняя все отложенные корутины, пока очередь задач не опустеет** ([Testing Kotlin coroutines on Android](https://developer.android.com/kotlin/coroutines/test#:~:text=advanceUntilIdle%20%3A%20Runs%20all%20other,choice%20to%20let%20all)). Таким образом, мы програмmatically доводим систему до «idle» состояния без реального ожидания, и можем сразу проводить проверки.

Подводя итог: **устойчивое состояние системы после Act – обязательное условие корректных проверок в тестах асинхронного кода**. Хотя конкретного термина «стазис» в ходу нет, идея широко воплощена через понятия *idle/quiescent/settled state*. Разработчики достигают этого состояния либо автоматически (благодаря возможностям тестовых фреймворков), либо вручную (синхронизируя задачи кодом или утилитами). Главное – убедиться, что **все асинхронные события завершены, все колбэки вызваны, и система больше не изменяется без новых стимулов**. Только в таком “спокойном” состоянии результаты действия можно надёжно проверить – будь то содержимое UI, состояние базы данных или значение переменных в памяти. Это и есть искомый «стазис» в тестировании: момент, когда система находится в кратком равновесии, готовая к Assertions без риска гонок и недетерминизма.

**Источник примеров и терминов:** концепция квиесценции и ожидания idle-состояния упоминается в документации и коде различных инструментов – от формальных тестовых моделей ([(PDF) CHESS: A systematic testing tool for concurrent software](https://www.academia.edu/7579489/CHESS_A_systematic_testing_tool_for_concurrent_software#:~:text=quiescent%20state%20is%20one%20in,of%20them%20to%20terminate%20before)) до практических советов (например, ожидание в Angular тестах через `whenStable()` ([unit testing - Does fixture.whenStable() actually do anything in my angular tests if not within an async test execution zone? - Stack Overflow](https://stackoverflow.com/questions/53479998/does-fixture-whenstable-actually-do-anything-in-my-angular-tests-if-not-within#:~:text=No%20the%20,just%20returns%20immediately))). Инженеры Google указывают, что автоматическое ожидание idle-состояния в Espresso значительно повысило стабильность UI-тестов ([A Comprehensive Guide To Espresso Testing | by Abhaya | Medium](https://medium.com/@abhaykhs/a-comprehensive-guide-to-espresso-testing-5149de2b1470#:~:text=2,making%20espresso%20automation%20more%20reliable)). В обсуждениях Kotlin/Coroutines также фигурирует понятие «quiescence period» – период отсутствия активности, на который ориентируются при проверках ([Discourage manual execution control in the test framework · Issue #3919 · Kotlin/kotlinx.coroutines · GitHub](https://github.com/Kotlin/kotlinx.coroutines/issues/3919#:~:text=system%20reaches%20a%20quiescence%20period,could%20you%20elaborate%20on%20them)). Все это подтверждает: хотя называют по-разному, **смысл один – дождаться полной **стабилизации** системы перед проверкой результата**.

#ai #research