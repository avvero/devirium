Код, не боящийся изменений
_ 

[[Evolvability]]

Картинка - референс на дом Уизли.

## Вступление

Вы помните, как он только появился? Такой маленький, красивый, не перегружен функциональностью и не испорчен вредными советами от дяди. А помните, как он неуверенно выкатывался на стенд, и бережные руки девопса помогали ему делать свои первые шаги? А его первые логи? Ничего не понятно, но он их пишет — пишет! А потом вы уехали в отпуск. Команда пообещала присматривать, но перекормила его плохопротестированными фичами. Он перестал влезать в старые лимиты, контейнеры трещали по швам. Прошли годы. Ваш милый ангелочек превратился в неповоротливого, прожорливого монстра, который сопротивляется любым попыткам обучить его новым фичам. Если раньше хватало недели, теперь и месяца мало.
Кто-то в такой момент уходит — в надежде, что в новой компании найдёт хорошего продакт-оунера, заведёт новые сервисы и не допустит прежних ошибок. Я же предлагаю другой путь: прокачивать навык **Evolvability** — способности системы меняться без боли.
В этой статье — немного личных наблюдений и советов о том, как сохранить проект живым и здоровым с течением лет. Без иллюзий всезнания. С лёгким, здоровым цинизмом.

## Evolvability



Когда программному проекту исполняется пять или десять лет, он начинает напоминать живой организм. Код со временем обрастает новыми частями, сбрасывает устаревшие "органы" и приспосабливается к меняющимся условиям. Способность системы **эволюционировать** — наверное, самое ценное качество для продукта, который хочет прожить долгую жизнь. Эту способность я называю страшным словом *эволвируемость* — то есть умение кода меняться со временем с минимальными издержками.

> эволвируемость -> Изменяемость?, Масштабируемость, адаптивность, Гибкость, Maintainability
> эволюционный мезанизм другой, огранизм не меняется, просто выживает сильнейший

На бумаге всё всегда гладко: архитектура распланирована, API продумано, база данных нормализована до третьей нормальной формы, тесты покрывают 100% логики. Но реальность смеётся над такими планами. Требования меняются, пользователи просят новое, курс бизнеса разворачивается на 180 градусов. То, что казалось отличным дизайном год назад, сегодня выглядит как курьёз или помеха развитию. В этой статье — немного наблюдений и советов о том, как сохранить проект живым и здоровым с течением лет, **без** иллюзий всезнания и с лёгким (здоровым) цинизмом.

В первые месяцы жизни сервиса доставка фичи занимает 1 неделю, а через год или два той же фичи уже 1 месяц. Сервис утратил способность меняться.

## Основной тезис

Система должна быть способна эволюционировать - меняться, подстраиваясь по условия среды. 

Способность меняться, быть гибким, легким, минимизируют издержки на сопровождение?

Решает проблему [[Software entropy]].

## Прозапас

Утенок идет в поход с огромным рюкзаком, из которого торчит торшер наполной лампы

## Не загадывай наперёд

Существует старая поговорка: "Хочешь насмешить бога — расскажи ему о своих планах". В разработке ПО она подходит идеально. Самая убойная ошибка в архитектуре — пытаться детально спроектировать **будущее**, которое ещё туманно и неизвестно. Мы все были там: сидишь на старте проекта, пытаешься учесть все возможные функции, расширения, нагрузки. Думаешь: а вдруг через год понадобится поддержка нескольких валют — надо сразу заложить? Или решаешь: пишем на вырост, заложим гибкий плагинный механизм — мало ли что.

Через год оказывается, что проект вообще развернул в другую сторону: про несколько валют забыли, зато понадобилось что-то совсем другое — например, интеграция с сервисом погодных предупреждений. И весь тот "прозапас" в коде не просто бесполезен, а мешает. Вы тратите время на поддержку абстракций, которые "вдруг пригодятся" — вместо того, чтобы быстро прикручивать реально нужный функционал.

Принцип **YAGNI** (You Aren't Gonna Need It — «тебе это не понадобится») в полную силу проявляется именно в эволюции продукта. Никакие мудрые архитекторы не способны идеально угадать, как система должна выглядеть через несколько лет. Поэтому нет смысла загадывать наперёд и усложнять дизайн в ожидании гипотетических требований. Проще сделать сегодня минимально работающее решение, удовлетворяющее требованиям, и улучшать его по мере поступления новый требований. Самое главное - выбранный дизайн не должен мешать возможным будущем изменениям, а должен быть к ним максимально лаялен. Тесты не должны цементировать код, а должны проверять контракт сервиса. 

Это не призыв бросаться в код без раздумий — думать о будущем полезно. Но есть тонкая грань между гибкостью и overengineering. Хороший архитектор не пытается построить универсальный швейцарский нож сразу. Он делает что-то одно — и держит в голове запасной план, что при необходимости этот нож можно будет перековать в вилку или даже в садовый секатор.

## Бросай в ту кучу

Утенок стоит у кучу железного хлама, он хочет сделать их нее машину или лодку.

[[One pile technic]].

## Не обобщай преждевременно

Разработка зрелого продукта учит смирению: ваши гениальные абстракции очень быстро сталкиваются с необычными частными случаями, о которых вы не подумали. Честно сказать, чаще всего **простое дублирование побеждает раннюю универсальность**. Это звучит противоречиво с позиций академической чистоты, но давайте будем реалистами.

Классический пример: приходит запрос "нужна ещё одна чуть-чуть другая форма отчёта". У вас уже есть класс `ReportGenerator` с парой наследников для разных форматов. Соблазн велик — сделать третий подкласс, а может, сразу придумать универсальный мегакласс с плагинами для любого формата? Но если эти отчёты действительно отличаются парой полей, зачастую быстрее и надёжнее... да, скопировать код существующего генератора и чуть поправить под новые нужды. Да, звучит как "плодить копипасту". Зато вы точно получите нужный результат быстро, без ломки существующей логики.

Предвосхищая крики о поддержке: конечно, копипаста имеет цену. Два похожих модуля придётся менять параллельно при общих изменениях. Но мой опыт подсказывает: **это меньшая из зол по сравнению с преждевременной генерализацией**. Слишком умная, обобщённая система часто оказывается негибкой. Стоит прийти случаю, который не укладывается в вашу изящную иерархию, и вы тратите больше сил на переделку абстракций, чем если бы просто имели два независимых простых решения.

Золотое правило здесь простое: обобщать имеет смысл только когда что-то повторилось три раза. Проще говоря:

* Один раз — вообще не повод для абстракции.
* Два раза — слабый сигнал: возможно, назревает третий.
* Три раза — всё, пора выделять общий механизм.

Следование этому правилу удерживает от порочной практики "написать фреймворк под одну задачу".

## Итерации важнее революций

Жизнь зрелого продукта — это непрерывная череда итераций. Вместо того чтобы раз в полгода выкатывать грандиозный релиз, команды еженедельно, а то и ежедневно, подкручивают винтики, добавляют по маленькой фиче, чинят баги. Такой ритм диктует и подход к разработке: решения принимаются быстрые, локальные. Код пишется "чтобы задачу решить сейчас", зная, что потом может прийти другой разработчик и всё переписать под новые нужды.

Кстати, о разработчиках. За годы жизни продукта их, скорее всего, сменится целая вереница. Каждый привнесёт свой стиль, свои идеи. Где-то в глубине `modules/` лежат файлы, авторы которых уже и не помнят, что они там понаписали в 2017 году. Пытаться "всё продумать заранее" в таких условиях особенно бесполезно: придёт новый человек со свежим взглядом — и ваше архитектурное предвидение покажется ему странным. Он скажет: "Зачем всё так сложно? Давайте проще сделаем" — и переделает половину системы.

Итеративность означает готовность постоянно менять курс маленькими шагами. Это как корректировка курса корабля: небольшие манёвры вместо резкого разворота на 90 градусов. Проект, который развивается итеративно, проще адаптировать: каждая маленькая доработка проверяет гипотезы и позволяет вовремя скорректировать путь. В противоположность этому, попытка сразу заложить монолитную "идеальную" архитектуру часто заканчивается большим рефакторингом или даже переписыванием, когда выясняется, что реальность отличается от плана.

## Графтинг: привил, вырастил, пересадил

Есть в садоводстве приём — прививка, или grafting: когда ветку одного растения прививают на ствол другого. В разработке тоже бывает похоже. Иногда, чтобы быстро развить новую фичу, её проще **привить** внутрь уже существующего сервиса, а не сразу городить отдельный модуль или микросервис. Вы внедряете новую функциональность "на чужой территории", пользуетесь всеми ресурсами и контекстом существующего кода. А когда эта веточка окрепнет, приживётся и докажет свою полезность — её можно аккуратно **отделить** и пересадить в собственный "горшок" (выделить в отдельный сервис или модуль).

Такой **графтинг** позволяет избежать ненужной преждевременной сложности. Зачастую страшно трогать старый монолит или большой сервис, и кажется правильным сразу все новые идеи выносить отдельно, "чтобы не дай бог не сломать ничего старого". Но правда в том, что **внутренняя интеграция быстрее и надёжнее** на ранних этапах. У вас уже есть инфраструктура, настройки, база данных — зачем плодить сущности, если можно быстро врезаться в существующие?

Конечно, у этого подхода есть и минусы — кодовая база временно раздувается, границы ответственности размываются, старый код обрастает "лишним". Но если держать в уме конечную цель (вынос фичи в самостоятельный компонент), такой долг можно постепенно отдать. Зато вы проверили идею с минимальными затратами, а потом спокойно сделали рефакторинг и вычистили чужеродный код из монолита.

## Тесты как страховка и тренировка

Не устану повторять: **тесты — лучшие друзья эволюционирующего кода**. Особенно интеграционные тесты, которые проверяют, что все куски системы продолжают дружить друг с другом после очередной серии изменений. Когда у вас сотня модулей и сервисов, легко случайно нарушить чей-то контракт или взаимосвязь. Интеграционные тесты сразу сигнализируют: "Эй, вчера всё работало, а сегодня падает, причём тут модуль авторизации?" — и вы быстро находите и чините проблему, пока она не ушла в продакшн.

> Интеграционные тесты завязаны на контракт и не проверяют реализацию, а значит реализацию можно менять

Отдельно хочется сказать про **TDD** (разработка через тестирование). Некоторые спорят о пользе TDD как методологии, но лично я нахожу один серьёзный плюс: написание тестов **до** кода дисциплинирует мышление. Когда ты сначала формулируешь, что система должна делать (в виде тестовых кейсов), требования словно укладываются у тебя в голове по полочкам. Это отличный способ прояснить задумку ещё до реализации. В контексте нашей темы это означает меньше шансов накодить лишнего или упустить что-то важное — ведь ты уже "прогнал" требование через мозг, пока писал тест.

Конечно, тесты — не панацея. Их тоже надо поддерживать, и плохие тесты могут мешать развитию не меньше, чем плохой код. Но без хоть какого-то набора тестов жить гораздо страшнее. Каждый рефакторинг превращается в рулетку: "прокатит/не прокатит". А страх менять код — главный убийца эволвируемости. Так что инвестиции в грамотный набор интеграционных тестов окупаются свободой: можно смело перепиливать хоть половину системы, зная, что все тесты зелёные, и это даёт уверенность в результате.

## База данных: проще, чем по учебнику

> С базой сложнее чем с кодом

Многие из нас учились проектировать базы данных по учебникам, где слово "денормализация" произносится шёпотом, как нечто постыдное. В реальной жизни эволюционирующего продукта **минимальная нормализация и даже некоторый избыток данных** — частые гости. Почему? Да потому что требования к данным тоже меняются, и очень тяжело заранее выбрать идеальную структуру.

В молодом проекте можно увидеть, как несколько разных функций хранит один и тот же кусочек данных каждый в своей таблице — потому что эти функции разрабатывались разными людьми, в разное время, без общей картины. Учебник ужаснулся бы: "редундантное хранение, нарушение 3НФ, ай-ай-ай". А на практике? Работает себе и ладно. Когда-нибудь потом сделают миграцию и объединят, если это реально мешает или влечёт баги. А может и не сделают — потому что дополнительный столбец в таблице отчётов никому жить не мешает, а код вокруг него давно устаканился.

Это не призыв плодить бардак в схеме данных. Но правда такова: **простая, даже если избыточная, схема часто лучше сложной идеальной модели**. Если какая-то новая сущность легко ложится в виде отдельной таблицы — сделайте таблицу, не мучайте существующую сложными связями. Пусть будут некоторые дубли — с хорошими тестами (см. предыдущий раздел) вы не потеряете целостность, а жить станет проще.

Ещё один аспект — производительность. Высокая нормализация подразумевает много JOIN-ов, сложные запросы. Пока данных мало — всё летает, но с ростом объёмов ваша красивая модель может начать тормозить. И вот тогда в бой идёт та самая денормализация, добавляются кэширующие таблицы, денормализованные колонки, дублирование. Получается, зря мучились: сразу бы так сделали. Лучше изначально закладывать структуру попроще, с расчётом на возможное упрощение запросов ценой разумного дублирования данных.

## Смирись: всё сразу не поймёшь (и это нормально)

Ещё одна вещь, которую приходится принять: **невозможно сразу понять всё** — ни в предметной области, ни в технической архитектуре. Часто мы начинаем проект или большую фичу с кучей неизвестных. Половину требований до конца не выяснили, по другой половине есть иллюзия, что выяснили (но потом всплывут детали). В итоге первый вариант системы пишется почти вслепую. И это нормально!

Важнее заложить возможность потом переделать, чем попытаться идеально попасть с первого выстрела. Большая беда некоторых разработчиков — нежелание переписывать "уже сделанное". Мол, "мы же столько времени потратили, как же так всё выбросить". А вот так. Выбросить и переписать — часто самый быстрый путь вперёд, как ни парадоксально. Код — не каменная плита, пусть даже мы стараемся писать его красиво и чисто. Если выяснилось, что текущее решение плохо масштабируется или не покрывает новый важный сценарий — лучше признать это и переделать, чем героически тащить на себе груз неудачной реализации.

Эволвируемость на практике означает, что **рефакторинг и переделка — это обычное дело**, а не ЧП. Архитектура должна предполагать заменяемость компонентов, модулей или алгоритмов с минимальными усилиями. Если какой-то модуль спроектирован так, что его не выкорчевать без переписывания всей системы — вот это уже тревожный звоночек (на заре проекта вы могли переусердствовать с "монолитностью").

Осознание ограниченности своих знаний ведёт к более гибкому проектированию: закладывать не конкретные предполагаемые расширения, а возможности для изменений в принципе. То есть вместо "мы заранее учли все кейсы" подход "мы сделали так, что новый кейс можно относительно безболезненно прикрутить".

## API не высечен в камне

Замечали, как порой в документации к какому-нибудь внутреннему API написано: "метод устарел, используйте новый" — и так несколько версий подряд? Это естественное свидетельство эволюции. Как ни стараешься продумать интерфейсы и контракты, практика показывает: **API всё равно меняется**. Возможно, реже, чем внутренняя логика, но меняться ему приходится.

Особенно это верно для внутренних API между сервисами. Ну не бывает так, чтобы за пять лет ни один эндпоинт не поменял сигнатуру. Даже если сам контракт стабильный, появляются новые версии, старые где-то отходят, или добавляются параметры. Зрелый продукт живёт в режиме постоянного перестроения, и API — часть этой жизни.

Как с этим жить? Во-первых, **версионирование**. Смиритесь, что рано или поздно придётся пилить v2, v3... Лучше заранее заложить возможность нескольких версий API, чтобы не ломать клиентов каждый раз. Во-вторых, политика устаревания: разрабатывайте стратегию, как вы будете выводить старый функционал. Пусть даже через "Deprecated" и год поддержки перед выпилом. Это лучше, чем пытаться навечно поддерживать первый вариант интерфейса, боясь гнева пользователей. Пользователи, кстати, тоже привыкают: лучше дать им чёткий план "старый API умрёт через N времени, переходите на новый", чем молчком менять поведение.

Ещё важный момент — **гибкость в интеграциях**. Если ваш продукт взаимодействует с чужими API, будьте готовы и там всё переписывать, когда партнёр обновится. Закладывайте время на эти вещи в планах. Ничто не застопорит эволюцию так, как внезапно сломавшаяся интеграция, под которую не были готовы выделить ресурсы.

## Заключение

Эволвируемость — это не про конкретный язык или фреймворк, а про подход к разработке. Это умение делать системы, которые могут менять шкуру, сбрасывать хвост ящерицы, отращивать новые конечности — и при этом продолжать выполнять свою работу. Для такого мастерства не существует серебряной пули, но есть общий настрой: **не высекать всё в граните**, быть готовым к переменам и не влюбляться в собственные решения до фанатизма.

Вместо послесловия — маленькая зарисовка. В одной компании существовал сервис, написанный ещё в начале 2010-х. Он прошёл огонь, воду и медные трубы: его код трижды переезжал на новые фреймворки, функциональность расширялась до неузнаваемости, API переписывался, менялись целевые пользователи. От изначального варианта там не осталось почти ничего, кроме, пожалуй, имени. Но знаете что? Сервис этот до сих пор в продакшене и приносит компании деньги. Наверное, это и есть главный признак успешной эволюции: **когда код, как Доктор Кто, меняет тело, но сохраняет душу и продолжает своё дело**.

#draft #article