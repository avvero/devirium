Evolvability или код, не боящийся изменений
_ 

[[Evolvability]]

Картинка - референс на дом Уизли.

Вставить ебаный каламбур типа "Не нужно по этому поводу лить слезу. Пока костыль работает, но после релиза с него точно слезу."

 / Вы можете уже не покупать одежду на вырост 

На берег выходит первое зимноводное - рыба, у которой отрасли ноги. И тут сразу голос с небес "чо застыл, ходи, дыши, отращивай большой палец, нет времени, на марс нужно лететь", а рыба отвечает "спина чешется". Все что мне нужно это уметь чесать спинку.

## Вступление

Вы помните, как он только появился? Такой маленький, красивый, не перегружен функциональностью и не испорчен вредными советами от чужого дяди. А помните, как он неуверенно выкатывался на стенд, и бережные руки девопса помогали ему делать свои первые шаги? А его первые логи? Ничего не понятно, но он их пишет — пишет! А потом вы уехали в отпуск. Команда пообещала присматривать, но перекормила его плохопротестированными фичами. Он перестал влезать в старые лимиты ресурсов, контейнеры трещали по швам. Прошли годы. Ваш милый ангелочек превратился в неповоротливого, прожорливого монстра, который сопротивляется любым попыткам обучить его новым фичам. Если раньше хватало недели, теперь и месяца мало.
Кто-то в такой момент уходит в другую компанию — в надежде, что найдёт хорошего продакт-оунера, заведёт новые сервисы и не допустит прежних ошибок. Я же предлагаю другой путь: писать код, не боящийся изменений и сохранить в нем способность расширяться без необходимости полной переработки.
В этой статье — немного личных наблюдений и советов о том, как сохранить проект живым и здоровым с течением лет. Без иллюзий всезнания. С лёгким, здоровым цинизмом.

## Evolvability

Evolvability — именно это слово я бы хотел использовать для описания способности системы изменяться: эволюционировать, адаптироваться, расширяться или развиваться со временем без необходимости полной переработки. Важно не столько наличие самой возможности вносить изменения, сколько сложность этих изменений. Целевая картина: добавление одной и той же фичи должно требовать примерно одинаковых усилий как на первом месяце жизни проекта, так и спустя два-три года. Я не нашел подходящего аналога в русском языке, поэтому использую термин «эволюционность». TODO или все же гибкость?

Evolvability — это антипод программной энтропии — ситуации, когда с увеличением возраста проекта его развитие замедляется. Проект может быстро стартует, но со временем становится все труднее добавлять новые фичи и исправлять ошибки. Результатом становится ситуация, когда каждый шаг требует значительных усилий и времени, что ведет к снижению общей скорости разработки.

## Не загадывай наперед

Существует старая поговорка: "Хочешь рассмешить бога — расскажи ему о своих планах". В разработке ПО она подходит идеально. Самая убойная ошибка в архитектуре — пытаться детально спроектировать будущее, которое туманно и неизвестно. Мы все были там: сидишь на старте проекта, пытаешься учесть все возможные функции, расширения, нагрузки. Думаешь: а вдруг через год понадобится поддержка нескольких валют — надо сразу заложить? Или решаешь: пишем на вырост, заложим гибкий плагинный механизм — мало ли что.

Через год оказывается, что проект вообще развернул в другую сторону: про несколько валют забыли, зато понадобилось что-то совсем другое — например, интеграция с сервисом индивидуальных гороскопов. И весь тот "прозапас" в коде не просто бесполезен, а мешает. Вы тратите время на поддержку кода, который "вдруг пригодятся" — вместо того, чтобы быстро прикручивать реально нужную функциональность.

Принцип YAGNI (You Aren't Gonna Need It — «тебе это не понадобится») в полную силу проявляется именно в эволюционности продукта. Если вас тригернуло упоминание гороскопов выше по тексту, то вы точно должны понять: мы не можем предсказать будущее. Никакие наимудрейшие разработчики (даже те, для кого чихнуть это однозначно подтвердить правильность произнесенного) не способны точно сказать, в какую сторону повернется бизнес и как система будет выглядеть через несколько лет. Поэтому нет смысла загадывать наперёд и усложнять дизайн в ожидании гипотетических требований. Проще сделать сегодня минимально работающее решение, удовлетворяющее требованиям, и улучшать его по мере поступления новый требований. Но самое главное - код не должен мешать возможным будущем изменениям, а должен им способствовать. В том числе, а может даже и в большем, это относится к коду тестов. Забегая вперед, скажу что, именно тестам я отдаю наиважнейшую роль - напишу об этом дальше (ок, поймали, это я могу предсказать). 

Это не призыв бросаться в код без раздумий — думать о будущем полезно. Но есть тонкая грань между гибкостью и overengineering. Не нужно делать универсальный швейцарский нож сразу. Нужно делать так, чтобы можно было легко переделать. И суть не в простоте, а в том на сколько это просто исправить. Сделали сложное решение? - ну ладно, потратили время, реализовали амбицию. Главное чтобы можно было легко это выкинуть.

### Не загадывай наперед даже ты

Небольшая ремарка. Даже если вы множество раз угадывали и ваше невероятное чутью стало синонимом непревзойденного величия и можете с высокой долей уверенности сказать, что будет дальше. То возможно вам нужно попробовать конные ставки, а вы теряете в ИТ свой дар предсказателя. И в этом будет плюс - основываясь на своих мистических ощущения вы поставите на кон свои деньги, а не чужой бизнес. 

## Не обобщай преждевременно

Разработка продукта учит смирению: ваши гениальные абстракции очень быстро сталкиваются с необычными частными случаями, о которых вы не подумали. Честно сказать, чаще всего простое дублирование побеждает раннюю универсальность. Это звучит противоречиво с позиций академической чистоты, но давайте будем реалистами.

Классический пример: приходит запрос "нужна ещё одна чуть-чуть другая форма отчёта". У вас уже есть класс `ReportGenerator` с парой наследников для разных форматов. Соблазн велик — сделать третий подкласс, а может, сразу придумать универсальный мегакласс с плагинами для любого формата? Но если эти отчёты действительно отличаются парой полей, зачастую быстрее и надёжнее... да, скопировать код существующего генератора и чуть поправить под новые нужды. Да, звучит как "плодить копипасту". Зато вы точно получите нужный результат быстро, без ломки существующей логики.

Предвосхищая крики о поддержке: конечно, копипаста имеет цену. Два похожих модуля придётся менять параллельно при общих изменениях. Но мой опыт подсказывает: это меньшая из зол по сравнению с преждевременной генерализацией. Слишком умная, обобщённая система часто оказывается негибкой. Стоит прийти случаю, который не укладывается в вашу изящную иерархию, и вы тратите больше сил на переделку абстракций, чем если бы просто имели два независимых простых решения.

Золотое правило здесь простое: обобщать имеет смысл только когда что-то повторилось три раза. Проще говоря:
* Один раз — вообще не повод для абстракции.
* Два раза — слабый сигнал: возможно, назревает третий.
* Три раза — всё, пора выделять общий механизм.

Следование этому правилу удерживает от порочной практики "написать фреймворк под одну задачу". Подобное правило мне встречалось в разных источника под следующими названиями: Правило трех конвертов, триангуляция, "1, 2, refactor" или "правило трех".

## One pile technic (перенести в "Не обобщай преждевременно"?)

Есть еще одна техника - One pile technic. Эта техника описана в книге "Tidy First?" Кента Бека. Основная мысль: чтение и понимание кода сложнее, чем его написание. Если код разбит на слишком много мелких частей, может быть полезно сначала объединить его в одно целое, чтобы увидеть общую структуру и логику, а затем снова разделить на более понятные куски.

В контексте данной статьи предлагается не разделять код на методы до тех пор, пока он не будет обеспечивать выполнение требуемого контракта.

## Итерации важнее революций

Жизнь продукта — это непрерывная череда итераций. Вместо того чтобы раз в полгода выкатывать грандиозный релиз, команды еженедельно, а то и ежедневно, подкручивают винтики, добавляют по маленькой фиче, чинят баги. Такой ритм диктует и подход к разработке: решения принимаются быстрые, локальные. Код пишется "чтобы задачу решить сейчас", зная, что потом может прийти другой разработчик и всё переписать под новые нужды.

Кстати, о разработчиках. За годы жизни продукта их, скорее всего, сменится целая вереница. Каждый привнесёт свой стиль, свои идеи. Где-то в глубине проекта лежат файлы, авторы которых уже и не помнят, что они там понаписали в 2017 году. Пытаться "всё продумать заранее" в таких условиях особенно бесполезно: придёт новый человек со свежим взглядом — и ваше архитектурное предвидение покажется ему странным. Он скажет: "Зачем всё так сложно? Давайте проще сделаем" — и переделает половину системы.

Итеративность означает готовность постоянно менять курс маленькими шагами. Это как корректировка курса -рубля- корабля: небольшие манёвры вместо резкого разворота на 90 градусов. Проект, который развивается итеративно, проще адаптировать: каждая маленькая доработка проверяет гипотезы и позволяет вовремя скорректировать путь. В противоположность этому, попытка сразу заложить готовую архитектуру часто заканчивается большим рефакторингом или даже переписыванием, когда выясняется, что реальность отличается от плана. И ваш проект и вы должны быть к этому готовы (todo или убрать это предложение?).

## Графтинг: привил, вырастил, пересадил

Есть в садоводстве приём — прививка, или grafting: когда ветку одного растения прививают на ствол другого. В разработке тоже бывает похоже. Иногда, чтобы быстро развить новую фичу, её проще привить внутрь уже существующего сервиса, а не сразу городить отдельный модуль или микросервис. Вы внедряете новую функциональность "на чужой территории", пользуетесь всеми ресурсами и контекстом существующего кода. А когда эта веточка окрепнет, приживётся и докажет свою полезность — её можно аккуратно отделить и пересадить в собственный "горшок" (выделить в отдельный сервис или модуль).

Такой подход позволяет избежать ненужной преждевременной сложности. Зачастую страшно трогать старый монолит или большой сервис, и кажется правильным сразу все новые идеи выносить отдельно, "чтобы не дай бог не сломать ничего старого". Но правда в том, что внутренняя интеграция быстрее и надёжнее на ранних этапах. У вас уже есть инфраструктура, настройки, база данных — зачем плодить сущности, если можно быстро "врезаться" в существующие?

Конечно, у этого подхода есть и минусы — кодовая база временно раздувается, границы ответственности размываются, старый код обрастает "лишним". Но если держать в уме конечную цель (вынос фичи в самостоятельный компонент), такой долг можно постепенно отдать. Зато вы проверили идею с минимальными затратами, а потом спокойно сделали рефакторинг и вычистили чужеродный код из "носителя".

## Тесты как страховка и тренировка

> картинка как человек в туалете подходит боизко и говорит, "Я люблю писать тесты"

Не устану повторять: тесты — лучшие друзья эволюционирующего кода. Когда у вас сотня модулей и сервисов, легко случайно нарушить чей-то контракт или взаимосвязь. Тесты сразу сигнализируют: "Эй, вчера всё работало, а сегодня падает, причём тут модуль авторизации?" — и вы быстро находите и чините проблему, пока она не ушла в продакшн.

Конечно, тесты — не панацея. Их тоже надо поддерживать, и плохие тесты могут мешать развитию не меньше, чем плохой код. Но без хоть какого-то набора тестов жить гораздо страшнее. Каждый рефакторинг превращается в рулетку: "прокатит/не прокатит". А страх менять код — главный убийца эволюционности. Мой личный выбор, проверенный годами на разного рода сервисах, это Testing Trophy. Это подход к покрытию кода тестами, при котором акцент делается на интеграционные тесты, проверяющие контракт сервиса в целом. А если тесты отвязаны от реализации, то саму реализацию можно менять хоть каждый день и это будет безопасно - контракт под контролем.

Отдельно хочется сказать про TDD (разработка через тестирование). Некоторые спорят о пользе TDD как методологии, но лично я нахожу один серьёзный плюс: Этот подход позволяет разделить усилия на написание кода для реализации контракта и на формирование дизайна кода. Мы не пытаемся сразу сделать хороший дизайн и написать код, соответствующий требованиям, а разделяем эти задачи. Это отличный способ дать коду отлежаться, созреть, ожидая рефакторинга. В контексте нашей темы это означает меньше шансов нагородить лишнего или упустить что-то важное.

## База данных: проще, чем по учебнику

> эволюционирующего, эволюционность - нада точнее

Многие из нас учились проектировать базы данных по учебникам, где слово "денормализация" произносится шёпотом, как нечто постыдное. В реальной жизни эволюционирующего продукта минимальная нормализация и даже некоторый избыток данных — частые гости. Почему? Да потому что требования к данным тоже меняются, и очень тяжело заранее выбрать идеальную структуру.

В молодом проекте можно увидеть, как несколько разных функций хранит один и тот же кусочек данных каждый в своей таблице — потому что эти функции разрабатывались разными людьми, в разное время, без общей картины. Учебник ужаснулся бы: "избыточное хранение, нарушение нормальных форм, ай-ай-ай". А на практике? Работает себе и ладно. Когда-нибудь потом сделают миграцию и объединят, если это реально мешает или провоцирует баги (хотя в этом случае хочется задать вопрос - а куда делись тесты?). А может и не сделают — потому что дополнительный столбец в таблице отчётов никому жить не мешает, а код вокруг него давно устаканился. "Это моя проблема или сервиса?" спросите вы. В эволюционирующем сервисе это не проблема вообще, потому что не создает проблем в доставке и поддержке и может быть легко исправлено. Это исправится, не нужно по этому поводу лить слезу.

Это не призыв плодить бардак в схеме данных. Но правда такова: простая, даже если избыточная, схема часто лучше сложной идеальной модели. Если какая-то новая сущность легко ложится в виде отдельной таблицы — сделайте таблицу, не мучайте существующую сложными связями. Пусть будут некоторые дубли — с хорошими тестами (см. предыдущий раздел) вы не потеряете целостность, а жить станет проще.

Ещё один аспект — производительность. Высокая нормализация подразумевает много JOIN-ов, сложные запросы. Пока данных мало — всё летает, но с ростом объёмов ваша красивая модель может начать тормозить. И вот тогда в бой идёт та самая денормализация, добавляются кэширующие таблицы, денормализованные колонки, дублирование. Получается, зря мучились: сразу бы так сделали. Лучше изначально закладывать структуру попроще, с расчётом на возможное упрощение запросов ценой разумного дублирования данных.

## Смирись: всё сразу не поймёшь (и это нормально)

Ещё одна вещь, которую приходится принять: невозможно сразу понять всё — ни в предметной области, ни в технической архитектуре. Часто мы начинаем проект или большую фичу с кучей неизвестных. Половину требований до конца не выяснили, по другой половине есть иллюзия, что выяснили (но потом всплывут детали). В итоге первый вариант системы пишется почти вслепую. И это нормально!

Важнее заложить возможность потом переделать, чем попытаться идеально попасть с первого выстрела. Большая беда некоторых разработчиков — нежелание переписывать "уже сделанное". Мол, "мы же столько времени потратили, как же так всё выбросить". А вот так. Выбросить и переписать — часто самый быстрый путь вперёд, как ни парадоксально. Код — не каменная плита, пусть даже мы стараемся писать его красиво и чисто. Если выяснилось, что текущее решение плохо масштабируется или не покрывает новый важный сценарий — лучше признать это и переделать, чем героически тащить на себе груз неудачной реализации.

Гибкость кода на практике означает, что рефакторинг и переделка — это обычное дело, а не ЧП. Ваш код должен быть к этому готов. Архитектура должна предполагать заменяемость компонентов, модулей или алгоритмов с минимальными усилиями. Если какой-то модуль спроектирован так, что его не выкорчевать без переписывания всей системы — вот это уже тревожный звоночек.

Осознание ограниченности своих знаний ведёт к более гибкому проектированию: закладывать не конкретные предполагаемые расширения, а возможности для изменений в принципе. То есть вместо "мы заранее учли все сценарии" подход "мы сделали так, что новый сценарий можно относительно безболезненно прикрутить".

## API не высечен в камне

Замечали, как порой в документации к какому-нибудь внутреннему API написано: "метод устарел, используйте новый" — и так несколько версий подряд? Это естественное свидетельство эволюции. Как ни стараешься продумать интерфейсы и контракты, практика показывает: API всё равно меняется. Возможно, реже, чем внутренняя логика, но меняться ему приходится.

Особенно это верно для внутренних API между сервисами. Ну не бывает так, чтобы за пять лет ни один эндпоинт не поменял сигнатуру. Даже если сам контракт стабильный, появляются новые версии, старые где-то отходят, или добавляются параметры. Зрелый продукт живёт в режиме постоянного перестроения, и API — часть этой жизни.

Как с этим жить? Во-первых, версионирование. Смиритесь, что рано или поздно придётся пилить v2, v3... Лучше заранее заложить возможность нескольких версий API, чтобы не ломать клиентов каждый раз. Во-вторых, политика устаревания: разрабатывайте стратегию, как вы будете выводить старую функциональность. Пусть даже через "Deprecated" и год поддержки перед выпиливанием. Это лучше, чем пытаться навечно поддерживать первый вариант интерфейса, боясь гнева пользователей. Пользователи, кстати, тоже привыкают: лучше дать им чёткий план "старый API умрёт через N времени, переходите на новый", чем молчком менять поведение, а потом стыдливо избегать этой темы.

Ещё важный момент — гибкость в интеграциях. Если ваш продукт взаимодействует с чужими API, будьте готовы и там всё переписывать, когда партнёр обновится. Закладывайте время на эти вещи в планах. Ничто не застопорит эволюцию так, как внезапно сломавшаяся интеграция, под которую не были готовы выделить ресурсы.

еще пару слов о [[Postel's law]]

## Заключение

Evolvability — это не про конкретный язык или фреймворк, а про подход к разработке. Это умение делать системы, которые могут менять шкуру, сбрасывать хвост ящерицы, отращивать новые конечности — и при этом продолжать выполнять свою работу. Для такого мастерства не существует серебряной пули, но есть общий настрой: не высекать всё в граните, быть готовым к переменам, быть к ним открытым и не влюбляться в собственные решения до фанатизма.

#draft #article