## Сокращение объема регрессионного тестирования.

Когда мы работаем над задачей, нам необходимо обеспечить качество внесенных изменений. Обычно это сопровождается необходимостью провести регрессионное тестирование. Чем более "перегружен" endpoint, тем больший объем такого тестирования нужно реализовать. Если говорим про http сервис, то подобное тестирование можно осуществить вручную через postman или иным образом. Проблема в том, что если кто-то после нас приходит в то же место и правит код, то и ему нужно провести регрессионное тестирование и так далее. Одним из способом автоматизации такой деятельность может быть написание тестов, проверяющий поведение приложения через публичный api с использованием моков для внепроцессных зависимостей. Данные тесты нужно интегрировать в цикл разработки.

Предлагается использовать единый уровень представления для вызовов api, проверки ответа и для мокирования в рамках интеграции с внепроцессными зависимостями. Для последнего предлагается использовать wiremock.

## Изолированный интеграционный тест

Если тестируется логика взаимодействия приложения с моком вместо реальных зависимостей, но само приложение работает в условиях, близких к реальному запуску (без изоляции отдельных классов, как в юнит-тестах).
Например, проверка, что сервис правильно формирует HTTP-запросы к базе данных через моки

## Контрактное тестирование

Контрактное тестирование — это методика тестирования точек интеграции, при которой каждое приложение проверяется в изоляции для подтверждения, что сообщения, которые оно отправляет или получает, соответствуют общему пониманию, задокументированному в "контракте". Этот подход позволяет убедиться, что взаимодействие между различными частями системы происходит в соответствии с ожиданиями. [[Повышаем наглядность интеграционных тестов]].

[[Качественна характеристика теста]]
[[Хороший юнит-тест]]

## Баланс между скоростью и качеством обратной связи у разных видов тестов

Важно не время выполнения теста, а время получения обратной связи от теста о работоспособности системы. Т.е. есть код и нужно проверить выполняет ли он требуемый контракт. Время выполнения тесты и время получения обратной связи это разные вещи. Давайте представим, что у нас есть e2e тесты и они запускаются на специально выделенном контуре. Чтобы проверить свежий код, нужно его закомитить, подождать прохождения quality gates, возможность review, если оно требуется для выката на стенд. Выкатить на стенд. Запустить тесты. Вот все это время от готовности кода к проверки и фактического запуска теста против этого кода и есть время получения обратной связи. Если для unit тестов это одна и та же величина, то для e2e это разные величины. При этом для e2e это время может измерятся часами, а то и больше. В то время как для unit тестов это миллисекунды. 

Интеграционные контрактные тесты по качеству обратной связи ближе к e2e теста, но по скорости ее получения ближе к unit.

## Время выполнения теста

Время выполнения теста это синтетическая характеристика, которая по сути ни о чем не говорит. Предлагаю рассмотреть такие:
- скорость получения обратной связи от теста
- качество обратной связи

Смотри, есть такие типы тестирования:
- unit
- интеграционные тесты (поднимается все приложение, внепроцессные зависимости мокируются c wiremock, проверка через api приложения)
- component testing (поднимается приложение и все его внепроцесные зависимости в docker и тестируется набором тестов похожим на e2e, но облегченным)
- e2e тесты

## Баланс между скоростью и качеством обратной связи у разных видов тестов

При сравнении unit-тестов, интеграционных, компонентных и E2E (end-to-end) тестов наблюдается обратная зависимость: чем быстрее тест дает обратную связь, тем менее всеобъемлющую информацию о работоспособности системы он предоставляет, и наоборот​. Ниже приведен график, иллюстрирующий эту зависимость (ось X – скорость получения обратной связи, ось Y – «качество» обратной связи, подразумевающее степень уверенности в корректной работе системы):
```
             ↑ Качество обратной связи (выше лучше)
             | ● E2E-тесты (сквозные)
             |       ● Интеграционные тесты
             |              ● Компонентные тесты
             |                        ● Unit-тесты
             +-----------------------------------------→ Скорость обратной связи (быстрее)
```

Unit-тесты. Юнит-тесты проверяют небольшие участки кода в изоляции. Они дают практически мгновенный фидбэк – выполняются за миллисекунды​, что обеспечивает очень высокую скорость обратной связи. Однако охват у них самый узкий: unit-тест гарантирует корректность отдельного модуля (функции, класса), но не выявляет проблем во взаимодействии компонентов. Качество обратной связи от таких тестов относительно невысокое в том смысле, что зелёные юнит-тесты еще не гарантируют работоспособность системы на уровне бизнес-сценариев. Зато сами по себе они чрезвычайно точечно указывают на место сбоя и легко локализуют дефекты в конкретном модуле.

Интеграционные тесты. Интеграционные тесты проверяют совместную работу нескольких модулей или сервисов. Они работают медленнее юнит-тестов (порядка секунд на тест)​, поэтому фидбэк приходит не так быстро. Зато эти тесты покрывают взаимодействия компонентов, повышая уверенность в том, что части системы правильно работают вместе. По качеству обратной связи интеграционные тесты занимают промежуточное положение: они выявляют дефекты на стыках модулей (что не видно юнит-тестам), хотя всё еще не охватывают систему целиком. При падении интеграционного теста приходится немного потрудиться, чтобы найти, в каком компоненте сбой, но обычно локализовать проблему проще, чем с E2E​.

Компонентные тесты. Компонентное тестирование можно рассматривать как проверку более крупного блока системы в относительно изолированной среде (например, тестирование отдельного сервиса целиком с его зависимостями, или UI-компонента со всеми подкомпонентами). По скорости такие тесты уступают юнит-тестам, так как затрагивают больше кода и могут требовать поднятия дополнительных частей системы (базы данных, оболочки приложения и т.д.). Однако компонентные тесты обычно быстрее полноценных сквозных E2E, поскольку сфокусированы на одном компоненте и могут выполнять часть действий в контролируемой среде. Качество обратной связи от компонентных тестов выше, чем у низкоуровневых тестов: они дают уверенность, что отдельный компонент (подсистема) в целом выполняет требуемые функции. Тем не менее, они не заменяют E2E, так как не охватывают взаимодействие данного компонента с остальной системой.

E2E-тесты. End-to-end тесты имитируют работу системы глазами пользователя, проверяя полный пользовательский сценарий от начала до конца. Такие тесты дают наибольшую ценность и качество обратной связи – высокий уровень уверенности, что вся система соответствует ожиданиям конечного пользователя​. Иными словами, если E2E-тесты проходят, значит основные бизнес-функции работают корректно в реальных условиях. Однако расплата за это – низкая скорость фидбэка. E2E-тесты самые медленные: один сценарий может выполняться десятки секунд или минуты​, а полный прогон большого набора E2E способен занять часы. Это значительно замедляет цикл обратной связи разработчика с системой. Кроме того, в случае падения E2E-теста известен лишь факт сбоя в сценарии, но не очевидна причина на уровне кода – приходится тратить время на поиски, в каком сервисе или модуле произошла ошибка​. Таким образом, сквозные тесты обеспечивают самую полную проверку (высокое качество обратной связи), но при самой медленной отдаче результата.

Вывод: быстрые низкоуровневые тесты (юнит) дают мгновенную обратную связь, но проверяют ограниченный контекст, тогда как медленные сквозные тесты охватывают систему целиком, давая более ценную информацию о её работе​. Интеграционные и компонентные тесты занимают промежуточный баланс между этими крайностями. На графике это отражено положением точек: юнит-тесты – в правом нижнем углу (максимальная скорость, минимальный охват), E2E – в левом верхнем (низкая скорость, максимальный охват), а интеграционное и компонентное тестирование располагаются между ними по диагонали. Такая диаграмма подчёркивает необходимость комбинировать разные уровни тестов, чтобы команда получала и быструю обратную связь при изменениях, и уверенность в качестве продукта на высоком уровне. Например, Google рекомендует стратегию тестирования с преобладанием быстрых юнит-тестов, дополняемых некоторым количеством интеграционных и небольшим числом E2E-тестов​ – это позволяет добиться разумного баланса между скоростью и качеством обратной связи.

## 


> Интеграционные тесты медленнее unit

Факт, но время выполнения теста это синтетическая характеристика, которой не достаточно для того, чтобы качественно принять 
решение о том, какому виду тестирования отдавать предпочтение. Наша главная задача - не выполнить тесты быстро, а 
гарантировать соблюдением кодом требований (функциональные и не функциональные). 
Предлагаю рассмотреть такие характеристики:
- время получения обратной связи от теста
- качество обратной связи

Время выполнения теста и время получения обратной связи это разные вещи. Давайте представим, что у нас есть e2e тесты и 
они запускаются на специально выделенном контуре. Чтобы проверить свежий код, нужно его закомитить, подождать 
прохождения quality gates, возможность review, если оно требуется для выката на стенд. Выкатить на стенд. Запустить тесты. 
Вот все это время от готовности кода к проверке и фактического завершения запуска теста против этого кода и есть время получения 
обратной связи. Для e2e это могут быть как часы, так и дни.

При сравнении unit-тестов, интеграционных, компонентных и E2E (end-to-end) тестов наблюдается обратная зависимость: чем 
быстрее тест дает обратную связь, тем менее точную и полную информацию о работоспособности системы он предоставляет, и наоборот.

Интеграционные тесты это компромисное решение, которое дает качество обратной связи ближе к e2e, а время получение этой 
связи близкое к unit.

При этом интеграционные тесты не цементируют код, как это делают unit тесты и позволяют выдерживать кодом характеристику 
evolvability (способность меняться, быть гибким, легким, минимизируют издержки на сопровождение), что особенно важно для 
сервисов на их раннем этапе. Данное утверждение находит отражение в книгах многих авторов, в том числе у 
Е. Бугаенко Angry Tests и у В. Хориков Принципы юнит-тестирования.
## 

Статья про тестинг трофеи

О чем статья: о том как в разработке сервисов отдаю предпочтение интеграционным тестам уровня сервиса, вижу в этом значительную пользу и с какими трудностями имею дело.

Интеграционная логика и бизнес логика, дать определения и значения

Обзервабилити, тест который медленный, но наглядно показывающий что-то

Тесты важнее кода. Изменения тестов и кода идут в параллельных таймлайнах с нахлестом.

Цель в доставке функциональностей с минимизацией затрат на разработку и поддержку кода.

Задачи:

-   Реализация желаемого бизнес поведения
-   Соблюдение Контрактов интеграционного характера (sla, api)
-   Создания условий, позволяющих минимизировать затраты на поддержку.
-   Рефакторинг (на мой практике гарнизонами планирования функциональностей - квартал, мы рассматриваем инициативы в начале и планируем доставку, мы точно знаем что мы реализуем в ближайший квартал, дальше ничего не знаем, если думаем что знаем - скорее всего будем разочарованы), поэтому невозможно строить долгоиграющий дизайн, тем более если сервис только появился. Важно чтобы сервис был эволвобильным (легко и дёшево меняться) с сохранением контракта. Интеграционные енд - то- енд тесты уровня сервиса помогают значительно.
-   Доступность и актуальность информации о текущей бизнес логике приложения (влияет на оценку времени разработки, в любой момент времени знаем что и как работает - например документация по апи содержит только интеграционную логику)

  

Дисклеймер: 1 Статья для тех, кто пишет код с багами и использует тесты для их нахождения. Или тех, кому интересно?

может содержать баги стремящиеся попасть на прод и кто выбрал тесты, как средство 

что использование тестов сводит к минимуму появление багов в проде 

2 в данной статье я в том числе поделюсь своими мыслями и опытом касательно интеграционных тестов и тдд. Я постараюсь обьяснить, а ни в чем-то убедить. Я не ставлю свой целью убедить , я хочу описать причины.

## Статьи с идеями

https://docs.pact.io/faq/convinceme - тут можно почитать о том, почему Contract tests save development time, суть та же и для TT.

----

Я познакомился давно, решил применять, у нас спринг и это было вызовом - медленно и плавающие баги.

Что такой тестинг трофи 
Дороже чем юнит 
В чем особенность спринга (контекст)
Шаред инстансы баз и Кафки и изоляция или дешевое поднятие сервисов
Что дает
Проблемы - баги спринга

---


Идея для картинки юнит и интеграционные 
Юнит - маленькой линейкой измеряет рост
Интеграции - большой линейкой 

Когда размер имеем значение и глубина


---

Основная мотивация
Перестать пользоваться постманом
Перенести в тесты то что я бы вызвал постманом 

---


Нет ни одной практики программирования, которая бы предложила способ написать такой код или ТАК его написать, который никто не будет менять. Вся затея с software буквально для того, чтобы делать «изменяемые» инструкции. Потому что меняется все. И все практики программирования направлены на то, чтобы писать поддерживаемый код. Т.е нужно писать код, который завтра кто-то перепишет. Так вот, покрытие кода юнитами это стрельнуть в ногу следующему разработчику. Интеграционные - помочь ему.


--- 

Важнотвремя обратной связи
Требования предъявляются к поведению
Юнит тесты не показывают поведение и не дают обратной связи о поведении
Если нет интеграционных тестов, то обратная связь по поведению будет только на iaas 


## 

- [The testing pyramid is an outdated economic model](https://www.wiremock.io/post/rethinking-the-testing-pyramid)
- [Testing of Microservices](https://engineering.atspotify.com/2018/01/testing-of-microservices/)
- [On the Diverse And Fantastical Shapes of Testing](https://martinfowler.com/articles/2021-test-shapes.html)

#testing #testing_trophy #draft